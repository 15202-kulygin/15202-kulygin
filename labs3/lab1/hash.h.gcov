        -:    0:Source:hash.h
        -:    0:Programs:4
        -:    1:#if !defined(HASH_H)
        -:    2:#define HASH_H
        -:    3:
        -:    4:#include <iostream>
        -:    5:#include <string>
        -:    6:#include <memory>
        -:    7:
        -:    8:#include "input.h"
        -:    9:
        -:   10:/*#if !defined(START_CAPACITY)
        -:   11:#define START_CAPACITY 4
        -:   12:#endif*/
        -:   13:
        -:   14:typedef class HashTable
        -:   15:{
        -:   16:  private:
        -:   17:    static const int START_CAPACITY = 4;
        -:   18:    int size;
        -:   19:    int capacity;
        -:   20:    Table * table;
        -:   21:    
        -:   22:  public:
        -:   23:    HashTable();
        -:   24:    HashTable(const HashTable& origin);
        -:   25:    ~HashTable();
        -:   26:    
        -:   27:    int gethash(Key key) const;
        -:   28:
        -:   29:    // Вставка в контейнер. Возвращаемое значение - успешность вставки.
        -:   30:    bool insert(const Key& k, const Value& v);
        -:   31:
        -:   32:    // Проверка наличия значения по заданному ключу.
        -:   33:    bool search(const Key& key) const;
        -:   34:    
        -:   35:    void print() const;
        -:   36:    
        -:   37:    void swap(HashTable& origin);
        -:   38:    
        -:   39:    HashTable& operator=(const HashTable& origin);
        -:   40:    
        -:   41:    // Очищает контейнер.
        -:   42:    void clear();
        -:   43:
        -:   44:     // Удаляет элемент по заданному ключу.
        -:   45:    bool erase(const Key& k);
        -:   46:
        -:   47:    int getsize() const;
        -:   48:    int getcapacity() const;
        -:   49:    Table * get_data() const;
        -:   50:
        -:   51:    bool empty() const;
        -:   52:
function _ZeqRK9HashTableS1_ called 8 returned 100% blocks executed 80%
        8:   53:    friend bool operator==(const HashTable & a, const HashTable & b)
        8:   53-block  0
        -:   54:    {
        8:   55:      if (a.size == b.size)
        8:   55-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        -:   56:      {
        8:   57:        for (int i = 0; i < a.capacity; ++i)
        8:   57-block  0
branch  0 taken 8 (fallthrough)
branch  1 taken 0
        -:   58:        {
        8:   59:          if (true == a.table[i].is_filled)
        8:   59-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 4
        -:   60:          {
        4:   61:            if (false == b.search(a.table[i].key))
        4:   61-block  0
call    0 returned 4
branch  1 taken 4 (fallthrough)
branch  2 taken 0
        -:   62:            {
        4:   63:              return false;
        4:   63-block  0
unconditional  0 taken 4
        -:   64:            }
        -:   65:          }
        4:   66:          return true;
        4:   66-block  0
unconditional  0 taken 4
    $$$$$:   66-block  1
unconditional  1 never executed
        -:   67:        }
        -:   68:      }
    #####:   69:      return false;
    $$$$$:   69-block  0
unconditional  0 never executed
        -:   70:    }
        -:   71:
function _ZneRK9HashTableS1_ called 2 returned 100% blocks executed 80%
        2:   72:    friend bool operator!=(const HashTable & a, const HashTable & b)
        2:   72-block  0
        -:   73:    {
        2:   74:      if (a == b)
        2:   74-block  0
call    0 returned 2
branch  1 taken 0 (fallthrough)
branch  2 taken 2
        -:   75:      {
    #####:   76:        return false;
    $$$$$:   76-block  0
unconditional  0 never executed
        -:   77:      }
        -:   78:      else
        -:   79:      {
        2:   80:        return true;
        2:   80-block  0
unconditional  0 taken 2
        -:   81:      }
        -:   82:    }
        -:   83:    void rehash();
        -:   84:    // Возвращает значение по ключу. Бросает исключение при неудаче.
        -:   85:    Value& at(const Key& k);
        -:   86:
        -:   87:    // Возвращает значение по ключу. Небезопасный метод.
        -:   88:    // В случае отсутствия ключа в контейнереа следует вставить в контейнер
        -:   89:    // значение, созданное конструктором по умолчанию и вернуть ссылку на него. 
        -:   90:    Value& operator[](const Key& k);
        -:   91:
        -:   92:    const Value& at(const Key& k) const;
        -:   93:} HashTable;
        -:   94:
        -:   95:
        -:   96:
        -:   97:#endif
